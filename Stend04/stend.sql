SET SERVEROUTPUT ON
SET DEFINE OFF
SET HEADING ON
SET ECHO ON
SET AUTOPRINT ON
SET LINESIZE 200
SET PAGESIZE 100

SPOOL _stend.log
-- Настраиваем таблицу

DECLARE
   v_cnt   NUMBER;
   c_row_counts pls_integer := 110000;
   v_row_count pls_integer;
BEGIN
   SELECT COUNT(*) AS cnt
     INTO v_cnt
     FROM dba_tables
    WHERE owner = 'RF'
      AND table_name = 'TABLE1';

   if (v_cnt = 1) then
     SELECT COUNT(*) into v_row_count FROM rf.table1; 
	 if (v_row_count != c_row_counts) then
	   execute immediate('drop table rf.table1');
	   v_cnt := 0;
	 end if;
   end if;
   
   IF (v_cnt = 0)
   THEN
      EXECUTE IMMEDIATE
         'CREATE TABLE RF.TABLE1(id NUMBER GENERATED BY DEFAULT AS IDENTITY, name VARCHAR2(128) not null) TABLESPACE QUORUM_DATA';

      FOR i IN 1 .. c_row_counts
      LOOP
         EXECUTE IMMEDIATE 'insert into RF.TABLE1(name) values (:1)' USING ('name_' || i);
      END LOOP;

      COMMIT;
   END IF;
END;
/

declare 
  type t_table is table of RF.TABLE1.NAME%type index by pls_integer;
  v_table t_table;
  start_time number;  
  duration_01 number;
  duration_02 number;
  duration_03 number;
  duration_04 number;
  duration_05 number;
  duration_06 number;
  duration_07 number;
  duration_08 number;
  duration_09 number;
  duration_10 number;
  v_clob clob;
  v_tmp_clob clob;
  v_tmp_varchar rf.table1.name%type;
  v_varchar_buffer varchar2(4000);
  v_buffer_size         PLS_INTEGER;
  c_max_size PLS_INTEGER := 4000;  
  v_row_count pls_integer;
begin
  
  -- извлекаем таблицу в коллекцию
  select name bulk collect into v_table from rf.table1;
  dbms_output.put_line(v_table.count || ' rows selected');
  
   -- 1. Слить конкатенацией целевой CLOB непосредственно со строкой:
   v_clob := '';
   start_time := DBMS_UTILITY.get_time;
   for i in 1..v_table.count loop
     v_clob := v_clob || v_table(i); 
   end loop;   
   duration_01 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('1. Clob length = ' || LENGTH(v_clob));
   
   -- 2. Преобразовать строку в CLOB и слить с уже существующим CLOB конкатенацией:
   start_time := DBMS_UTILITY.get_time;
   v_clob := '';
   for i in 1..v_table.count loop
     v_clob := v_clob || to_clob(v_table(i)); 
   end loop;   
   duration_02 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('2. Clob length = ' || LENGTH(v_clob));
   
   -- 3. Присвоить строку существующему объекту CLOB и слить его с целевым CLOB конкатенацией:
   start_time := DBMS_UTILITY.get_time;
   v_clob := '';
   for i in 1..v_table.count loop
     v_tmp_clob := v_table(i);
     v_clob := v_clob || v_tmp_clob; 
   end loop;      
   duration_03 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('3. Clob length = ' || LENGTH(v_clob));
   
   -- 4. Поместить строку во временную строку типа VARCHAR2 и слить ее с целевым CLOB конкатенацией:
   start_time := DBMS_UTILITY.get_time;    
   v_clob := '';
   for i in 1..v_table.count loop
     v_tmp_varchar := v_table(i);
     v_clob := v_clob || v_tmp_varchar; 
   end loop;     
   duration_04 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('4. Clob length = ' || LENGTH(v_clob));
   
   -- 5. Использовать метод DBMS_LOB.append с аргументом типа VARCHAR2:   
   dbms_lob.createtemporary(v_clob, TRUE);
   start_time := DBMS_UTILITY.get_time;
   for i in 1..v_table.count loop
     dbms_lob.append(v_clob, v_table(i)); 
   end loop;   
   duration_05 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('5. Clob length = ' || LENGTH(v_clob));
   
   -- 6. Использовать метод DBMS_LOB.append с аргументом типа CLOB:
   dbms_lob.createtemporary(v_clob, TRUE);
   start_time := DBMS_UTILITY.get_time;
   for i in 1..v_table.count loop
     dbms_lob.append(v_clob, to_clob(v_table(i))); 
   end loop;   
   duration_06 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('6. Clob length = ' || LENGTH(v_clob));
   
   -- 7. Использовать метод DBMS_LOB.append с временной переменной типа VARCHAR2:
   dbms_lob.createtemporary(v_clob, TRUE);
   start_time := DBMS_UTILITY.get_time;   
   for i in 1..v_table.count loop
     v_tmp_varchar := v_table(i);
     dbms_lob.append(v_clob, v_tmp_varchar); 
   end loop; 
   duration_07 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('7. Clob length = ' || LENGTH(v_clob));
   
   -- 8. Использовать метод DBMS_LOB.append с временной переменной типа CLOB:
   dbms_lob.createtemporary(v_clob, TRUE);   
   start_time := DBMS_UTILITY.get_time;
   for i in 1..v_table.count loop
     v_tmp_clob := v_table(i);
     dbms_lob.append(v_clob, v_tmp_clob); 
   end loop;
   duration_08 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('8. Clob length = ' || LENGTH(v_clob));
   
   -- 9. Использовать буферную переменную + конкатенация к CLOB-у:
   v_clob := NULL;
   v_varchar_buffer := NULL;
   start_time := DBMS_UTILITY.get_time;
   
   FOR i IN 1 .. v_table.COUNT
   LOOP        
        v_buffer_size := NVL(LENGTH(v_varchar_buffer), 0) + NVL(LENGTH(v_table(i)), 0);
        
        if (v_buffer_size >= c_max_size) or (i = v_table.COUNT) then
            v_clob := v_clob || v_varchar_buffer || v_table(i);
            v_varchar_buffer := null;
        else
            v_varchar_buffer := v_varchar_buffer || v_table(i);
        end if;      
   END LOOP;
   
   duration_09 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('9. Clob length = ' || LENGTH(v_clob));
   
   -- 10. Использовать буферную переменную + метод DBMS_LOB.append:
   dbms_lob.createtemporary(v_clob, TRUE);
   start_time := DBMS_UTILITY.get_time;   
   for i in 1..v_table.count loop
        v_buffer_size := NVL(LENGTH(v_varchar_buffer), 0) + NVL(LENGTH(v_table(i)), 0);
        
        if (v_buffer_size >= c_max_size) or (i = v_table.COUNT) then
            dbms_lob.append(v_clob, v_table(i) || v_varchar_buffer);
            v_varchar_buffer := null;
        else
            v_varchar_buffer := v_varchar_buffer || v_table(i);
        end if;      
   end loop; 
   duration_10 := (DBMS_UTILITY.get_time - start_time) / 100;
   DBMS_OUTPUT.put_line('10. Clob length = ' || LENGTH(v_clob));
   
   SELECT COUNT(*) into v_row_count FROM rf.table1; 
  
  -- Итоговый отчет:
  DBMS_OUTPUT.PUT_LINE('Для ' || v_row_count || ' строк:');
  DBMS_OUTPUT.PUT_LINE('Вариант №1 - Слить конкатенацией целевой CLOB непосредственно со строкой:                                 '|| duration_01 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №2 - Преобразовать строку в CLOB и слить с уже существующим CLOB конкатенацией:                   '|| duration_02 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №3 - Присвоить строку существующему объекту CLOB и слить его с целевым CLOB конкатенацией:        '|| duration_03 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №4 - Поместить строку во временную строку типа VARCHAR2 и слить ее с целевым CLOB конкатенацией:  '|| duration_04 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №5 - Использовать метод DBMS_LOB.append с аргументом типа VARCHAR2:                               '|| duration_05 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №6 - Использовать метод DBMS_LOB.append с аргументом типа CLOB:                                   '|| duration_06 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №7 - Использовать метод DBMS_LOB.append с временной переменной типа VARCHAR2:                     '|| duration_07 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №8 - Использовать метод DBMS_LOB.append с временной переменной типа CLOB:                         '|| duration_08 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №9 - Использовать буферную переменную + конкатенация к CLOB-у:                                    '|| duration_09 ||' сек');
  DBMS_OUTPUT.PUT_LINE('Вариант №10 - Использовать буферную переменную + метод DBMS_LOB.append:                                   '|| duration_10 ||' сек');  
end;
/

SPOOL OFF
SET ECHO OFF
EXIT